! Autogenerated Fortran interfaces for ../include/sparseir/sparseir.h
subroutine c_spir_kernel_release(obj) &
    bind(c, name="spir_kernel_release")
  use iso_c_binding
  type(c_ptr), value :: obj
end subroutine

type(c_ptr) function c_spir_kernel_clone(src) &
    bind(c, name="spir_kernel_clone")
  use iso_c_binding
  type(c_ptr), value :: src
end function

integer(c_int) function c_spir_kernel_is_assigned(obj) &
    bind(c, name="spir_kernel_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
end function

subroutine c_spir_funcs_release(obj) &
    bind(c, name="spir_funcs_release")
  use iso_c_binding
  type(c_ptr), value :: obj
end subroutine

type(c_ptr) function c_spir_funcs_clone(src) &
    bind(c, name="spir_funcs_clone")
  use iso_c_binding
  type(c_ptr), value :: src
end function

integer(c_int) function c_spir_funcs_is_assigned(obj) &
    bind(c, name="spir_funcs_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
end function

subroutine c_spir_basis_release(obj) &
    bind(c, name="spir_basis_release")
  use iso_c_binding
  type(c_ptr), value :: obj
end subroutine

type(c_ptr) function c_spir_basis_clone(src) &
    bind(c, name="spir_basis_clone")
  use iso_c_binding
  type(c_ptr), value :: src
end function

integer(c_int) function c_spir_basis_is_assigned(obj) &
    bind(c, name="spir_basis_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
end function

subroutine c_spir_sampling_release(obj) &
    bind(c, name="spir_sampling_release")
  use iso_c_binding
  type(c_ptr), value :: obj
end subroutine

type(c_ptr) function c_spir_sampling_clone(src) &
    bind(c, name="spir_sampling_clone")
  use iso_c_binding
  type(c_ptr), value :: src
end function

integer(c_int) function c_spir_sampling_is_assigned(obj) &
    bind(c, name="spir_sampling_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
end function

subroutine c_spir_sve_result_release(obj) &
    bind(c, name="spir_sve_result_release")
  use iso_c_binding
  type(c_ptr), value :: obj
end subroutine

type(c_ptr) function c_spir_sve_result_clone(src) &
    bind(c, name="spir_sve_result_clone")
  use iso_c_binding
  type(c_ptr), value :: src
end function

integer(c_int) function c_spir_sve_result_is_assigned(obj) &
    bind(c, name="spir_sve_result_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
end function

type(c_ptr) function c_spir_logistic_kernel_new(lambda, status) &
    bind(c, name="spir_logistic_kernel_new")
  use iso_c_binding
  real(c_double), value :: lambda
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_reg_bose_kernel_new(lambda, status) &
    bind(c, name="spir_reg_bose_kernel_new")
  use iso_c_binding
  real(c_double), value :: lambda
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_kernel_domain(k, xmin, xmax, ymin, ymax) &
    bind(c, name="spir_kernel_domain")
  use iso_c_binding
  type(c_ptr), value :: k
  type(c_ptr), value :: xmin
  type(c_ptr), value :: xmax
  type(c_ptr), value :: ymin
  type(c_ptr), value :: ymax
end function

type(c_ptr) function c_spir_sve_result_new(k, epsilon, status) &
    bind(c, name="spir_sve_result_new")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_sve_result_get_size(sve, size) &
    bind(c, name="spir_sve_result_get_size")
  use iso_c_binding
  type(c_ptr), value :: sve
  type(c_ptr), value :: size
end function

integer(c_int) function c_spir_sve_result_get_svals(sve, svals) &
    bind(c, name="spir_sve_result_get_svals")
  use iso_c_binding
  type(c_ptr), value :: sve
  type(c_ptr), value :: svals
end function

integer(c_int) function c_spir_funcs_get_size(funcs, size) &
    bind(c, name="spir_funcs_get_size")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: size
end function

type(c_ptr) function c_spir_funcs_get_slice(funcs, nslice, indices, status) &
    bind(c, name="spir_funcs_get_slice")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: nslice
  type(c_ptr), value :: indices
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_funcs_eval(funcs, x, out) &
    bind(c, name="spir_funcs_eval")
  use iso_c_binding
  type(c_ptr), value :: funcs
  real(c_double), value :: x
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_funcs_eval_matsu(funcs, x, out) &
    bind(c, name="spir_funcs_eval_matsu")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: x
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_funcs_batch_eval(funcs, order, num_points, xs, out) &
    bind(c, name="spir_funcs_batch_eval")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_points
  type(c_ptr), value :: xs
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_funcs_batch_eval_matsu(funcs, order, num_freqs, matsubara_freq_indices, out) &
    bind(c, name="spir_funcs_batch_eval_matsu")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_freqs
  type(c_ptr), value :: matsubara_freq_indices
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_funcs_get_n_roots(funcs, n_roots) &
    bind(c, name="spir_funcs_get_n_roots")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: n_roots
end function

integer(c_int) function c_spir_funcs_get_roots(funcs, roots) &
    bind(c, name="spir_funcs_get_roots")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: roots
end function

type(c_ptr) function c_spir_basis_new(statistics, beta, omega_max, k, sve, status) &
    bind(c, name="spir_basis_new")
  use iso_c_binding
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  type(c_ptr), value :: k
  type(c_ptr), value :: sve
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_basis_get_size(b, size) &
    bind(c, name="spir_basis_get_size")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: size
end function

integer(c_int) function c_spir_basis_get_svals(b, svals) &
    bind(c, name="spir_basis_get_svals")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
end function

integer(c_int) function c_spir_basis_get_stats(b, statistics) &
    bind(c, name="spir_basis_get_stats")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: statistics
end function

integer(c_int) function c_spir_basis_get_singular_values(b, svals) &
    bind(c, name="spir_basis_get_singular_values")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
end function

type(c_ptr) function c_spir_basis_get_u(b, status) &
    bind(c, name="spir_basis_get_u")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_basis_get_v(b, status) &
    bind(c, name="spir_basis_get_v")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_basis_get_uhat(b, status) &
    bind(c, name="spir_basis_get_uhat")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_basis_get_n_default_taus(b, num_points) &
    bind(c, name="spir_basis_get_n_default_taus")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
end function

integer(c_int) function c_spir_basis_get_default_taus(b, points) &
    bind(c, name="spir_basis_get_default_taus")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: points
end function

integer(c_int) function c_spir_basis_get_n_default_ws(b, num_points) &
    bind(c, name="spir_basis_get_n_default_ws")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
end function

integer(c_int) function c_spir_basis_get_default_ws(b, points) &
    bind(c, name="spir_basis_get_default_ws")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: points
end function

integer(c_int) function c_spir_basis_get_n_default_matsus(b, positive_only, num_points) &
    bind(c, name="spir_basis_get_n_default_matsus")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: num_points
end function

integer(c_int) function c_spir_basis_get_default_matsus(b, positive_only, points) &
    bind(c, name="spir_basis_get_default_matsus")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: points
end function

type(c_ptr) function c_spir_dlr_new(b, status) &
    bind(c, name="spir_dlr_new")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_dlr_new_with_poles(b, npoles, poles, status) &
    bind(c, name="spir_dlr_new_with_poles")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: npoles
  type(c_ptr), value :: poles
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_dlr_get_npoles(dlr, num_poles) &
    bind(c, name="spir_dlr_get_npoles")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: num_poles
end function

integer(c_int) function c_spir_dlr_get_poles(dlr, poles) &
    bind(c, name="spir_dlr_get_poles")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: poles
end function

integer(c_int) function c_spir_ir2dlr_dd(dlr, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_dd")
  use iso_c_binding
  type(c_ptr), value :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_ir2dlr_zz(dlr, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_zz")
  use iso_c_binding
  type(c_ptr), value :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_dlr2ir_dd(dlr, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_dd")
  use iso_c_binding
  type(c_ptr), value :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_dlr2ir_zz(dlr, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_zz")
  use iso_c_binding
  type(c_ptr), value :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

type(c_ptr) function c_spir_tau_sampling_new(b, num_points, points, status) &
    bind(c, name="spir_tau_sampling_new")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_tau_sampling_new_with_matrix(order, statistics, basis_size, num_points, points, matrix, status) &
    bind(c, name="spir_tau_sampling_new_with_matrix")
  use iso_c_binding
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_matsu_sampling_new(b, positive_only, num_points, points, status) &
    bind(c, name="spir_matsu_sampling_new")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
end function

type(c_ptr) function c_spir_matsu_sampling_new_with_matrix(order, statistics, basis_size, positive_only, num_points, points, matrix, status) &
    bind(c, name="spir_matsu_sampling_new_with_matrix")
  use iso_c_binding
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
end function

integer(c_int) function c_spir_sampling_get_npoints(s, num_points) &
    bind(c, name="spir_sampling_get_npoints")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: num_points
end function

integer(c_int) function c_spir_sampling_get_taus(s, points) &
    bind(c, name="spir_sampling_get_taus")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: points
end function

integer(c_int) function c_spir_sampling_get_matsus(s, points) &
    bind(c, name="spir_sampling_get_matsus")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: points
end function

integer(c_int) function c_spir_sampling_get_cond_num(s, cond_num) &
    bind(c, name="spir_sampling_get_cond_num")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: cond_num
end function

integer(c_int) function c_spir_sampling_eval_dd(s, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dd")
  use iso_c_binding
  type(c_ptr), value :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_sampling_eval_dz(s, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dz")
  use iso_c_binding
  type(c_ptr), value :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_sampling_eval_zz(s, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_zz")
  use iso_c_binding
  type(c_ptr), value :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_sampling_fit_dd(s, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_dd")
  use iso_c_binding
  type(c_ptr), value :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function

integer(c_int) function c_spir_sampling_fit_zz(s, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_zz")
  use iso_c_binding
  type(c_ptr), value :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
end function


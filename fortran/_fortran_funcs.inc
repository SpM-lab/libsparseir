! Autogenerated Fortran-friendly interfaces
subroutine destroy_kernel(obj)
  use iso_c_binding
  type(spir_kernel), intent(inout) :: obj
  call c_spir_destroy_kernel(  obj%%ptr)
end subroutine

function clone_kernel(src) result(clone_kernel)
  use iso_c_binding
  type(spir_kernel), intent(in) :: src
  clone_kernel = c_spir_clone_kernel(  src%%ptr)
end function

function is_assigned_kernel(obj) result(is_assigned_kernel)
  use iso_c_binding
  type(spir_kernel), intent(in) :: obj
  is_assigned_kernel = c_spir_is_assigned_kernel(  obj%%ptr)
end function

subroutine destroy_funcs(obj)
  use iso_c_binding
  type(spir_funcs), intent(inout) :: obj
  call c_spir_destroy_funcs(  obj%%ptr)
end subroutine

function clone_funcs(src) result(clone_funcs)
  use iso_c_binding
  type(spir_funcs), intent(in) :: src
  clone_funcs = c_spir_clone_funcs(  src%%ptr)
end function

function is_assigned_funcs(obj) result(is_assigned_funcs)
  use iso_c_binding
  type(spir_funcs), intent(in) :: obj
  is_assigned_funcs = c_spir_is_assigned_funcs(  obj%%ptr)
end function

subroutine destroy_matsubara_funcs(obj)
  use iso_c_binding
  type(spir_matsubara_funcs), intent(inout) :: obj
  call c_spir_destroy_matsubara_funcs(  obj%%ptr)
end subroutine

function clone_matsubara_funcs(src) result(clone_matsubara_funcs)
  use iso_c_binding
  type(spir_matsubara_funcs), intent(in) :: src
  clone_matsubara_funcs = c_spir_clone_matsubara_funcs(  src%%ptr)
end function

function is_assigned_matsubara_funcs(obj) result(is_assigned_matsubara_funcs)
  use iso_c_binding
  type(spir_matsubara_funcs), intent(in) :: obj
  is_assigned_matsubara_funcs = c_spir_is_assigned_matsubara_funcs(  obj%%ptr)
end function

subroutine destroy_finite_temp_basis(obj)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(inout) :: obj
  call c_spir_destroy_finite_temp_basis(  obj%%ptr)
end subroutine

function clone_finite_temp_basis(src) result(clone_finite_temp_basis)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: src
  clone_finite_temp_basis = c_spir_clone_finite_temp_basis(  src%%ptr)
end function

function is_assigned_finite_temp_basis(obj) result(is_assigned_finite_temp_basis)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: obj
  is_assigned_finite_temp_basis = c_spir_is_assigned_finite_temp_basis(  obj%%ptr)
end function

subroutine destroy_sampling(obj)
  use iso_c_binding
  type(spir_sampling), intent(inout) :: obj
  call c_spir_destroy_sampling(  obj%%ptr)
end subroutine

function clone_sampling(src) result(clone_sampling)
  use iso_c_binding
  type(spir_sampling), intent(in) :: src
  clone_sampling = c_spir_clone_sampling(  src%%ptr)
end function

function is_assigned_sampling(obj) result(is_assigned_sampling)
  use iso_c_binding
  type(spir_sampling), intent(in) :: obj
  is_assigned_sampling = c_spir_is_assigned_sampling(  obj%%ptr)
end function

subroutine destroy_sve_result(obj)
  use iso_c_binding
  type(spir_sve_result), intent(inout) :: obj
  call c_spir_destroy_sve_result(  obj%%ptr)
end subroutine

function clone_sve_result(src) result(clone_sve_result)
  use iso_c_binding
  type(spir_sve_result), intent(in) :: src
  clone_sve_result = c_spir_clone_sve_result(  src%%ptr)
end function

function is_assigned_sve_result(obj) result(is_assigned_sve_result)
  use iso_c_binding
  type(spir_sve_result), intent(in) :: obj
  is_assigned_sve_result = c_spir_is_assigned_sve_result(  obj%%ptr)
end function

subroutine destroy_dlr(obj)
  use iso_c_binding
  type(spir_dlr), intent(inout) :: obj
  call c_spir_destroy_dlr(  obj%%ptr)
end subroutine

function clone_dlr(src) result(clone_dlr)
  use iso_c_binding
  type(spir_dlr), intent(in) :: src
  clone_dlr = c_spir_clone_dlr(  src%%ptr)
end function

function is_assigned_dlr(obj) result(is_assigned_dlr)
  use iso_c_binding
  type(spir_dlr), intent(in) :: obj
  is_assigned_dlr = c_spir_is_assigned_dlr(  obj%%ptr)
end function

function logistic_kernel_new(kernel, lambda) result(logistic_kernel_new)
  use iso_c_binding
  type(c_ptr) :: kernel
  real(c_double), value :: lambda
  logistic_kernel_new = c_spir_logistic_kernel_new(  kernel,
  lambda)
end function

function regularized_bose_kernel_new(kernel, lambda) result(regularized_bose_kernel_new)
  use iso_c_binding
  type(c_ptr) :: kernel
  real(c_double), value :: lambda
  regularized_bose_kernel_new = c_spir_regularized_bose_kernel_new(  kernel,
  lambda)
end function

function sve_result_new(sve, k, epsilon) result(sve_result_new)
  use iso_c_binding
  type(c_ptr) :: sve
  type(spir_kernel), intent(in) :: k
  real(c_double), value :: epsilon
  sve_result_new = c_spir_sve_result_new(  sve,
  k%%ptr,
  epsilon)
end function

function kernel_domain(k, xmin, xmax, ymin, ymax) result(kernel_domain)
  use iso_c_binding
  type(spir_kernel), intent(in) :: k
  real(c_double), intent(out) :: xmin
  real(c_double), intent(out) :: xmax
  real(c_double), intent(out) :: ymin
  real(c_double), intent(out) :: ymax
  kernel_domain = c_spir_kernel_domain(  k%%ptr,
  xmin,
  xmax,
  ymin,
  ymax)
end function

function finite_temp_basis_get_size(b, size) result(finite_temp_basis_get_size)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: b
  integer(c_int), intent(out) :: size
  finite_temp_basis_get_size = c_spir_finite_temp_basis_get_size(  b%%ptr,
  size)
end function

function finite_temp_basis_get_statistics(b, statistics) result(finite_temp_basis_get_statistics)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: b
  integer(c_int), intent(out) :: statistics
  finite_temp_basis_get_statistics = c_spir_finite_temp_basis_get_statistics(  b%%ptr,
  statistics)
end function

function sampling_get_statistics(s, statistics) result(sampling_get_statistics)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), intent(out) :: statistics
  sampling_get_statistics = c_spir_sampling_get_statistics(  s%%ptr,
  statistics)
end function

function tau_sampling_new(s, b) result(tau_sampling_new)
  use iso_c_binding
  type(c_ptr) :: s
  type(spir_finite_temp_basis), intent(in) :: b
  tau_sampling_new = c_spir_tau_sampling_new(  s,
  b%%ptr)
end function

function matsubara_sampling_new(s, b, positive_only) result(matsubara_sampling_new)
  use iso_c_binding
  type(c_ptr) :: s
  type(spir_finite_temp_basis), intent(in) :: b
  integer(c_int), value :: positive_only
  matsubara_sampling_new = c_spir_matsubara_sampling_new(  s,
  b%%ptr,
  positive_only)
end function

function matsubara_sampling_dlr_new(s, dlr, n_smpl_points, smpl_points, positive_only) result(matsubara_sampling_dlr_new)
  use iso_c_binding
  type(c_ptr) :: s
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), value :: n_smpl_points
  integer(c_int), intent(out) :: smpl_points
  integer(c_int), value :: positive_only
  matsubara_sampling_dlr_new = c_spir_matsubara_sampling_dlr_new(  s,
  dlr%%ptr,
  n_smpl_points,
  smpl_points,
  positive_only)
end function

function matsubara_sampling_get_sampling_points(s, n_points, points) result(matsubara_sampling_get_sampling_points)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: n_points
  integer(c_int), intent(out) :: points
  matsubara_sampling_get_sampling_points = c_spir_matsubara_sampling_get_sampling_points(  s%%ptr,
  n_points,
  points)
end function

function matsubara_sampling_get_num_points(s, n_points) result(matsubara_sampling_get_num_points)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), intent(out) :: n_points
  matsubara_sampling_get_num_points = c_spir_matsubara_sampling_get_num_points(  s%%ptr,
  n_points)
end function

function dlr_new(dlr, b) result(dlr_new)
  use iso_c_binding
  type(c_ptr) :: dlr
  type(spir_finite_temp_basis), intent(in) :: b
  dlr_new = c_spir_dlr_new(  dlr,
  b%%ptr)
end function

function dlr_new_with_poles(dlr, b, npoles, poles) result(dlr_new_with_poles)
  use iso_c_binding
  type(c_ptr) :: dlr
  type(spir_finite_temp_basis), intent(in) :: b
  integer(c_int), value :: npoles
  real(c_double), intent(out) :: poles
  dlr_new_with_poles = c_spir_dlr_new_with_poles(  dlr,
  b%%ptr,
  npoles,
  poles)
end function

function dlr_get_statistics(dlr, statistics) result(dlr_get_statistics)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), intent(out) :: statistics
  dlr_get_statistics = c_spir_dlr_get_statistics(  dlr%%ptr,
  statistics)
end function

function sampling_evaluate_dd(s, order, ndim, input_dims, target_dim, input, out) result(sampling_evaluate_dd)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  real(c_double), intent(out) :: input
  real(c_double), intent(out) :: out
  sampling_evaluate_dd = c_spir_sampling_evaluate_dd(  s%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function sampling_evaluate_dz(s, order, ndim, input_dims, target_dim, input, out) result(sampling_evaluate_dz)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  real(c_double), intent(out) :: input
  type(c_ptr), intent(out) :: out
  sampling_evaluate_dz = c_spir_sampling_evaluate_dz(  s%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function sampling_evaluate_zz(s, order, ndim, input_dims, target_dim, input, out) result(sampling_evaluate_zz)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), intent(in) :: input
  type(c_ptr), intent(out) :: out
  sampling_evaluate_zz = c_spir_sampling_evaluate_zz(  s%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function sampling_fit_dd(s, order, ndim, input_dims, target_dim, input, out) result(sampling_fit_dd)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  real(c_double), intent(out) :: input
  real(c_double), intent(out) :: out
  sampling_fit_dd = c_spir_sampling_fit_dd(  s%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function sampling_fit_zz(s, order, ndim, input_dims, target_dim, input, out) result(sampling_fit_zz)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), intent(in) :: input
  type(c_ptr), intent(out) :: out
  sampling_fit_zz = c_spir_sampling_fit_zz(  s%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function dlr_get_num_poles(dlr, num_poles) result(dlr_get_num_poles)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), intent(out) :: num_poles
  dlr_get_num_poles = c_spir_dlr_get_num_poles(  dlr%%ptr,
  num_poles)
end function

function dlr_get_poles(dlr, poles) result(dlr_get_poles)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  real(c_double), intent(out) :: poles
  dlr_get_poles = c_spir_dlr_get_poles(  dlr%%ptr,
  poles)
end function

function dlr_from_IR_dd(dlr, order, ndim, input_dims, target_dim, input, out) result(dlr_from_IR_dd)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  real(c_double), intent(out) :: input
  real(c_double), intent(out) :: out
  dlr_from_IR_dd = c_spir_dlr_from_IR_dd(  dlr%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function dlr_from_IR_zz(dlr, order, ndim, input_dims, target_dim, input, out) result(dlr_from_IR_zz)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), intent(in) :: input
  type(c_ptr), intent(out) :: out
  dlr_from_IR_zz = c_spir_dlr_from_IR_zz(  dlr%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function dlr_to_IR_dd(dlr, order, ndim, input_dims, target_dim, input, out) result(dlr_to_IR_dd)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  real(c_double), intent(out) :: input
  real(c_double), intent(out) :: out
  dlr_to_IR_dd = c_spir_dlr_to_IR_dd(  dlr%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function dlr_to_IR_zz(dlr, order, ndim, input_dims, target_dim, input, out) result(dlr_to_IR_zz)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  integer(c_int), intent(out) :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), intent(in) :: input
  type(c_ptr), intent(out) :: out
  dlr_to_IR_zz = c_spir_dlr_to_IR_zz(  dlr%%ptr,
  order,
  ndim,
  input_dims,
  target_dim,
  input,
  out)
end function

function dlr_get_u(dlr, u) result(dlr_get_u)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  type(c_ptr) :: u
  dlr_get_u = c_spir_dlr_get_u(  dlr%%ptr,
  u)
end function

function dlr_get_uhat(dlr, uhat) result(dlr_get_uhat)
  use iso_c_binding
  type(spir_dlr), intent(in) :: dlr
  type(c_ptr) :: uhat
  dlr_get_uhat = c_spir_dlr_get_uhat(  dlr%%ptr,
  uhat)
end function

function finite_temp_basis_new(b, statistics, beta, omega_max, epsilon) result(finite_temp_basis_new)
  use iso_c_binding
  type(c_ptr) :: b
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  real(c_double), value :: epsilon
  finite_temp_basis_new = c_spir_finite_temp_basis_new(  b,
  statistics,
  beta,
  omega_max,
  epsilon)
end function

function finite_temp_basis_new_with_sve(b, statistics, beta, omega_max, k, sve) result(finite_temp_basis_new_with_sve)
  use iso_c_binding
  type(c_ptr) :: b
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  type(spir_kernel), intent(in) :: k
  type(spir_sve_result), intent(in) :: sve
  finite_temp_basis_new_with_sve = c_spir_finite_temp_basis_new_with_sve(  b,
  statistics,
  beta,
  omega_max,
  k%%ptr,
  sve%%ptr)
end function

function finite_temp_basis_get_u(b, u) result(finite_temp_basis_get_u)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: b
  type(c_ptr) :: u
  finite_temp_basis_get_u = c_spir_finite_temp_basis_get_u(  b%%ptr,
  u)
end function

function finite_temp_basis_get_v(b, v) result(finite_temp_basis_get_v)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: b
  type(c_ptr) :: v
  finite_temp_basis_get_v = c_spir_finite_temp_basis_get_v(  b%%ptr,
  v)
end function

function finite_temp_basis_get_uhat(b, uhat) result(finite_temp_basis_get_uhat)
  use iso_c_binding
  type(spir_finite_temp_basis), intent(in) :: b
  type(c_ptr) :: uhat
  finite_temp_basis_get_uhat = c_spir_finite_temp_basis_get_uhat(  b%%ptr,
  uhat)
end function

function funcs_get_size(funcs, size) result(funcs_get_size)
  use iso_c_binding
  type(spir_funcs), intent(in) :: funcs
  integer(c_int), intent(out) :: size
  funcs_get_size = c_spir_funcs_get_size(  funcs%%ptr,
  size)
end function

function evaluate_funcs(funcs, x, out) result(evaluate_funcs)
  use iso_c_binding
  type(spir_funcs), intent(in) :: funcs
  real(c_double), value :: x
  real(c_double), intent(out) :: out
  evaluate_funcs = c_spir_evaluate_funcs(  funcs%%ptr,
  x,
  out)
end function

function evaluate_matsubara_funcs(uiw, order, num_freqs, matsubara_freq_indices, out) result(evaluate_matsubara_funcs)
  use iso_c_binding
  type(spir_matsubara_funcs), intent(in) :: uiw
  integer(c_int), value :: order
  integer(c_int), value :: num_freqs
  integer(c_int), intent(out) :: matsubara_freq_indices
  type(c_ptr), intent(out) :: out
  evaluate_matsubara_funcs = c_spir_evaluate_matsubara_funcs(  uiw%%ptr,
  order,
  num_freqs,
  matsubara_freq_indices,
  out)
end function

function sampling_get_num_points(s, num_points) result(sampling_get_num_points)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), intent(out) :: num_points
  sampling_get_num_points = c_spir_sampling_get_num_points(  s%%ptr,
  num_points)
end function

function sampling_get_tau_points(s, points) result(sampling_get_tau_points)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  real(c_double), intent(out) :: points
  sampling_get_tau_points = c_spir_sampling_get_tau_points(  s%%ptr,
  points)
end function

function sampling_get_matsubara_points(s, points) result(sampling_get_matsubara_points)
  use iso_c_binding
  type(spir_sampling), intent(in) :: s
  integer(c_int), intent(out) :: points
  sampling_get_matsubara_points = c_spir_sampling_get_matsubara_points(  s%%ptr,
  points)
end function

function matsubara_funcs_get_size(funcs, size) result(matsubara_funcs_get_size)
  use iso_c_binding
  type(spir_matsubara_funcs), intent(in) :: funcs
  integer(c_int), intent(out) :: size
  matsubara_funcs_get_size = c_spir_matsubara_funcs_get_size(  funcs%%ptr,
  size)
end function


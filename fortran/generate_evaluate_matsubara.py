#!/usr/bin/env python3
"""
Auto-generate evaluate_matsubara_impl.inc file for Fortran module.

This script generates evaluate_matsubara functions for 1d to 7d arrays
based on the template in tmp.f90.
"""

import os

def generate_shape_string(ndim):
    """Generate shape string for given dimension."""
    if ndim == 1:
        return "(:)"
    elif ndim == 2:
        return "(:,:)"
    elif ndim == 3:
        return "(:,:,:)"
    elif ndim == 4:
        return "(:,:,:,:)"
    elif ndim == 5:
        return "(:,:,:,:,:)"
    elif ndim == 6:
        return "(:,:,:,:,:,:)"
    elif ndim == 7:
        return "(:,:,:,:,:,:,:)"
    else:
        raise ValueError(f"Unsupported dimension: {ndim}")

def generate_evaluate_matsubara_function(ndim, input_type, output_type):
    """Generate evaluate_matsubara function for given dimension and type combination."""
    shape_str = generate_shape_string(ndim)
    
    # Generate dimension array declaration
    dim_array_decl = f"INTEGER(KIND=c_int), TARGET :: input_dims_c({ndim}), output_dims_c({ndim})"
    
    # Determine types and C function
    func_suffix = f"{input_type}{output_type}"
    
    # Input type
    if input_type == 'z':
        input_fortran_type = "COMPLEX(KIND=DP)"
        input_c_type = "COMPLEX(KIND=c_double)"
    elif input_type == 'd':
        input_fortran_type = "REAL(KIND=DP)"
        input_c_type = "REAL(KIND=c_double)"
    else:
        raise ValueError(f"Unsupported input type: {input_type}")
    
    # Output type
    if output_type == 'z':
        output_fortran_type = "COMPLEX(KIND=DP)"
        output_c_type = "COMPLEX(KIND=c_double)"
    elif output_type == 'd':
        output_fortran_type = "REAL(KIND=DP)"
        output_c_type = "REAL(KIND=c_double)"
    else:
        raise ValueError(f"Unsupported output type: {output_type}")
    
    # C function
    c_function = f"c_spir_sampling_eval_{func_suffix}"
    
    # Generate the function
    function = f"""SUBROUTINE evaluate_matsubara_{func_suffix}_{ndim}d(obj, statistics, target_dim, arr, res)
  TYPE(IR), INTENT(IN) :: obj
  INTEGER, INTENT(IN) :: statistics
  INTEGER, INTENT(IN) :: target_dim

  {input_fortran_type}, INTENT(IN), TARGET :: arr {shape_str}

  {output_fortran_type}, INTENT(OUT), TARGET :: res {shape_str}
  INTEGER(KIND=c_int) :: ndim_c, target_dim_c, status_c
  {dim_array_decl}
  input_dims_c = SHAPE(arr)
  output_dims_c = SHAPE(res)
  ndim_c = {ndim}
  IF (target_dim < 1 .or. target_dim > {ndim}) THEN
    CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Target dimension is out of range', 1)
  ENDIF
  IF (input_dims_c(target_dim) /= obj%size) THEN
    CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Target dimension is not the same as the basis size', 1)
  ENDIF
  SELECT CASE (statistics)
  CASE (SPIR_STATISTICS_FERMIONIC)
    IF (output_dims_c(target_dim) /= obj%nfreq_f) THEN
      CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Target dimension is not the same as the number of Matsubara frequencies', 1)
    ENDIF
  CASE (SPIR_STATISTICS_BOSONIC)
    IF (output_dims_c(target_dim) /= obj%nfreq_b) THEN
      CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Target dimension is not the same as the number of Matsubara frequencies', 1)
    ENDIF
  END SELECT
  IF (.NOT. check_output_dims(target_dim, input_dims_c, output_dims_c)) THEN
    CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', &
        'Output dimensions are not the same as the input dimensions except for the TARGET dimension', 1)
  ENDIF
  target_dim_c = target_dim - 1
  SELECT CASE (statistics)
  CASE (SPIR_STATISTICS_FERMIONIC)
    status_c = {c_function}(obj%matsu_f_smpl_ptr, SPIR_ORDER_COLUMN_MAJOR, &
      ndim_c, c_loc(input_dims_c), target_dim_c, c_loc(arr), c_loc(res))
  CASE (SPIR_STATISTICS_BOSONIC)
    status_c = {c_function}(obj%matsu_b_smpl_ptr, SPIR_ORDER_COLUMN_MAJOR, &
      ndim_c, c_loc(input_dims_c), target_dim_c, c_loc(arr), c_loc(res))
  CASE DEFAULT
    CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Invalid statistics', 1)
    RETURN
  END SELECT
  IF (status_c /= 0) THEN
    CALL errore('evaluate_matsubara_{func_suffix}_{ndim}d', 'Error evaluating on Matsubara frequencies', status_c)
  ENDIF
END SUBROUTINE"""
    
    return function

def generate_all_functions():
    """Generate all evaluate_matsubara functions for 1d to 7d with different type combinations."""
    content = []
    
    # Header comment
    content.append("! Auto-generated file - do not edit manually")
    content.append("! Generated by generate_evaluate_matsubara.py")
    content.append("! Based on template from tmp.f90")
    content.append("")
    
    # Type combinations: (input_type, output_type)
    input_output_types = [('z', 'z'), ('d', 'z')]
    
    # Generate functions for each type combination and dimension
    for input_type, output_type in input_output_types:
        for ndim in range(1, 8):  # 1d to 7d
            function = generate_evaluate_matsubara_function(ndim, input_type, output_type)
            content.append(function)
            content.append("")
    
    return "\n".join(content)

def main():
    """Main function to generate the file."""
    output_file = "evaluate_matsubara_impl.inc"
    
    print(f"Generating {output_file}...")
    
    content = generate_all_functions()
    
    # Write to file
    with open(output_file, 'w') as f:
        f.write(content)
    
    print(f"Successfully generated {output_file}")
    print(f"Total lines: {len(content.splitlines())}")
    print(f"Generated functions for dimensions: 1d to 7d")
    print(f"Type combinations: (z,z) and (d,z)")

if __name__ == "__main__":
    main()

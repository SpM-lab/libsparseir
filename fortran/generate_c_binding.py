import clang.cindex
from clang.cindex import Index, TypeKind, CursorKind


def map_c_type_to_fortran(ctype):
    """Map a C type to a Fortran iso_c_binding type."""
    kind = ctype.kind
    if kind == TypeKind.VOID:
        return 'subroutine'
    elif kind == TypeKind.DOUBLE:
        return 'real(c_double), value'
    elif kind == TypeKind.INT or kind == TypeKind.INT:
        return 'integer(c_int), value'
    elif kind == TypeKind.UINT or kind == TypeKind.UINT:
        return 'integer(c_int), value'
    elif kind == TypeKind.POINTER:
        pointee = ctype.get_pointee()
        type_name = pointee.get_canonical().spelling
        is_const = 'const' in type_name
        if pointee.kind == TypeKind.RECORD:
            return 'type(c_ptr), intent(in)' if is_const else 'type(c_ptr), intent(out)'
        elif pointee.kind == TypeKind.DOUBLE:
            return 'real(c_double), intent(out)'
        elif pointee.kind == TypeKind.COMPLEX:
            return 'complex(c_double_complex), intent(out)'
        elif pointee.kind == TypeKind.INT:
            return 'integer(c_int), intent(out)'
        elif pointee.kind == TypeKind.ENUM:
            return 'integer(c_int), intent(out)'
        elif pointee.kind == TypeKind.ELABORATED:
            if type_name in ["spir_statistics_type", "spir_order_type"]:
                return 'integer(c_int), intent(out)'
            return 'type(c_ptr), intent(in)' if is_const else 'type(c_ptr), intent(out)'
        else:
            return 'type(c_ptr)'
    elif kind == TypeKind.COMPLEX:
        return 'complex(c_double_complex), value'
    elif kind == TypeKind.ENUM:
        return 'integer(c_int), value'
    elif kind == TypeKind.ELABORATED:
        type_name = ctype.get_canonical().spelling
        if type_name in ["spir_statistics_type", "spir_order_type"]:
            return 'integer(c_int), value'
        return 'type(c_ptr)'
    else:
        return 'type(c_ptr)'  # default fallback


def generate_fortran_interface(cursor):
    """Generate Fortran interface code from a C function declaration."""
    if cursor.kind != CursorKind.FUNCTION_DECL:
        return ""

    func_name = cursor.spelling
    fortran_func_name = f"c_{func_name}"
    result_type = map_c_type_to_fortran(cursor.result_type)

    args = []
    decls = []
    for arg in cursor.get_arguments():
        name = arg.spelling or 'arg'
        ftype = map_c_type_to_fortran(arg.type)
        args.append(name)
        decls.append(f"  {ftype} :: {name}")

    arglist = ', '.join(args)
    decl_lines = '\n'.join(decls)

    if result_type == 'subroutine':
        return f"""
subroutine {fortran_func_name}({arglist}) bind(c, name="{func_name}")
  use iso_c_binding
{decl_lines}
end subroutine
""".strip()
    else:
        result_decl = f"  {result_type.split(',')[0]} :: {fortran_func_name}"
        return f"""
function {fortran_func_name}({arglist}) bind(c, name="{func_name}") result({fortran_func_name})
  use iso_c_binding
{decl_lines}
{result_decl}
end function
""".strip()


def generate_fortran_type_definition(type_name):
    """Generate Fortran type definition for an C type."""
    fortran_type_name = f"spir_{type_name}"
    return f"""  type :: {fortran_type_name}
    type(c_ptr) :: ptr = c_null_ptr
  contains
    procedure :: is_initialized => {type_name}_is_initialized
    procedure :: clone => {type_name}_clone
    procedure :: assign => {type_name}_assign
    generic :: assignment(=) => assign  ! Overload assignment operator
    final :: {type_name}_finalize
  end type

"""

def main():
    import sys
    if len(sys.argv) < 2:
        print("Usage: python generate_fortran_interfaces.py spir_sample.h")
        return

    header_path = sys.argv[1]
    index = Index.create()
    tu = index.parse(header_path, args=['-x', 'c', '-std=c99'])

    # Generate interface bindings
    interfaces = []
    for cursor in tu.cursor.get_children():
        if cursor.location.file and cursor.location.file.name == header_path:
            code = generate_fortran_interface(cursor)
            if code:
                interfaces.append(code)

    # Write interface bindings
    with open("_cbinding.inc", 'w') as f:
        f.write("! Autogenerated Fortran interfaces for " + header_path + "\n")
        for code in interfaces:
            f.write(code + "\n\n")

    # Generate type definitions
    C_types = [
        "kernel",
        "funcs",
        "matsubara_funcs",
        "finite_temp_basis",
        "sampling",
        "sve_result",
        "dlr"
    ]

    # Write type definitions
    with open("_fortran_types.inc", 'w') as f:
        f.write("! Autogenerated Fortran type definitions\n")
        for type_name in C_types:
            f.write(generate_fortran_type_definition(type_name))
    
    print("Generated Fortran interfaces written to _cbinding.inc")
    print("Generated Fortran type definitions written to _fortran_types.inc")


if __name__ == "__main__":
    main()

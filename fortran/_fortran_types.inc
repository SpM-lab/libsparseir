! Autogenerated Fortran type definitions
  type :: spir_dlr
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_dlr  ! Overload assignment operator
    final :: spir_destroy_spir_dlr
  end type

  ! Assignment operator implementation
  module procedure assign_spir_dlr
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_dlr(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_dlr(rhs%ptr)
    end if
  end procedure

  type :: spir_finite_temp_basis
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_finite_temp_basis  ! Overload assignment operator
    final :: spir_destroy_spir_finite_temp_basis
  end type

  ! Assignment operator implementation
  module procedure assign_spir_finite_temp_basis
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_finite_temp_basis(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_finite_temp_basis(rhs%ptr)
    end if
  end procedure

  type :: spir_funcs
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_funcs  ! Overload assignment operator
    final :: spir_destroy_spir_funcs
  end type

  ! Assignment operator implementation
  module procedure assign_spir_funcs
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_funcs(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_funcs(rhs%ptr)
    end if
  end procedure

  type :: spir_kernel
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_kernel  ! Overload assignment operator
    final :: spir_destroy_spir_kernel
  end type

  ! Assignment operator implementation
  module procedure assign_spir_kernel
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_kernel(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_kernel(rhs%ptr)
    end if
  end procedure

  type :: spir_matsubara_funcs
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_matsubara_funcs  ! Overload assignment operator
    final :: spir_destroy_spir_matsubara_funcs
  end type

  ! Assignment operator implementation
  module procedure assign_spir_matsubara_funcs
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_matsubara_funcs(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_matsubara_funcs(rhs%ptr)
    end if
  end procedure

  type :: spir_sampling
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_sampling  ! Overload assignment operator
    final :: spir_destroy_spir_sampling
  end type

  ! Assignment operator implementation
  module procedure assign_spir_sampling
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_sampling(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_sampling(rhs%ptr)
    end if
  end procedure

  type :: spir_sve_result
    type(c_ptr) :: ptr = c_null_ptr
  contains
    generic :: assignment(=) => assign_spir_sve_result  ! Overload assignment operator
    final :: spir_destroy_spir_sve_result
  end type

  ! Assignment operator implementation
  module procedure assign_spir_sve_result
    ! Check for self-assignment
    if (c_associated(lhs%ptr, rhs%ptr)) then
      return
    end if
    
    ! Clean up existing resource if present
    if (c_associated(lhs%ptr)) then
      call c_spir_destroy_spir_sve_result(lhs%ptr)
      lhs%ptr = c_null_ptr
    end if
    
    ! If RHS is valid, clone it
    if (c_associated(rhs%ptr)) then
      lhs%ptr = c_spir_clone_spir_sve_result(rhs%ptr)
    end if
  end procedure

